回车 回车 tab  来变色
## 1.//安卓中用来获取屏幕宽度和高度

        WindowManager mWM = (WindowManager) getSystemService(WINDOW_SERVICE); //得到一个窗口管理者  当然它的作用是用来管理窗口的
        Display defaultDisplay = mWM.getDefaultDisplay();
        
        DisplayMetrics metrics= new DisplayMetrics();
        defaultDisplay.getMetrics(metrics);
        
        int windowWidth=metrics.widthPixels;    //屏幕宽度
        int windowHeight=metrics.heightPixels;  //屏幕高度
        这是直接调用系统的方法 当然更简单
        int width=getResources().getDisplayMetrics().widthPixels;//获取屏幕宽度
        int hight=getResources().getDisplayMetrics().heightPixels;//获取屏幕高度
## 2.//事件分发器（dispatchTouchEvent）之setOnTouchListener与setOnClickListener
    为什么onTouch返回false之后，onclick才可以执行？
    为什么返回false之后，onTouch仍然可以收到事件序列。
    源代码分析
    每个控件都有个事件分发器（dispatchTouchEvent）  它来管理事件的调用顺序 
    在setOnTouchListener中只有result = false；的时候才会调用setOnClickListener方法  并且在此之后才能继续执行
    如果只有setOnTouchListener只有 result = true;时他自己才能继续执行

    //原理分析
    dispatchTouchEvent()
       if (onFilterTouchEventForSecurity(event)) {
                //noinspection SimplifiableIfStatement
                ListenerInfo li = mListenerInfo;
                if (li != null && li.mOnTouchListener != null
                        && (mViewFlags & ENABLED_MASK) == ENABLED
                        && li.mOnTouchListener.onTouch(this, event)) {
                    result = true;
                }
                if (!result && onTouchEvent(event)) {
                    result = true;
                }
            }
     //实例
     //这里setOnTouchListener
      ll_setlocation_toast.setOnTouchListener(new View.OnTouchListener() {
             public boolean onTouch(View v, MotionEvent event) {
                switch (event.getAction()) {
                        return false;//在这里返回false时可以执行后面的操作，返回true时不能执行后面的操作
                }
            }
        });
     ll_setlocation_toast.setOnClickListener(new View.OnClickListener() {
      public void onClick(View v) {
       }
        });
            
            
            
       //其它例子     
       //这里setOnItemLongClickListener先执行setOnItemClickListener后执行
    lv_phonemanager_blacknum.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener() {
            @Override
            public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long id) {
             return true;
             //这里返回true的话在长按的时候就不会出现setOnItemClickListener的事件 但如果返回false的话就会在longitem后执行setOnItemClickListener事件
             //如果只有自己返回值是true还是false没有关系
            }
        });
     lv_phonemanager_blacknum.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {}
        });
        
## 3.//获取当前时间的毫秒数（距离1970年1月1日）

        firstclicktime= System.currentTimeMillis();
        //获得本机的时间
        String time = new Date().toLocaleString();
        SimpleDateFormat sdformat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");//24小时制    
         SimpleDateFormat ss = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");//12小时制  
         str = sdformat.format(ss);
      //获取当前的时间
        SimpleDateFormat formatter = new SimpleDateFormat("yyyyMMddhhmmss");
        Date curDate = new Date(System.currentTimeMillis());//获取当前时间
        String str = formatter.format(curDate);

		 long time = System.nanoTime();//得到系统的纳秒时间


## 4.//隐藏ActionBarActivity上面的bar 


        final android.support.v7.app.ActionBar supportActionBar = getSupportActionBar();
        supportActionBar.hide();    
## 5.//得到本机的SIM卡的逻辑

        TelephonyManager mTelmanager = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);
        String imsi = mTelmanager.getSimSerialNumber();//得到本机的SIM卡的号码
            
## 6.//直接调用系统的联系人的功能  

        Intent pickContactIntent = new Intent(Intent.ACTION_PICK, Uri.parse("content://contacts"));
        pickContactIntent.setType(ContactsContract.CommonDataKinds.Phone.CONTENT_TYPE);
        startActivityForResult(pickContactIntent, 100);//回调函数 当选完联系人之后调用
## 7.//将数据库从src/main/assets目录下 copy到 data/data/packagename/  在splash页面用的

    public void copydb(){
        File db = new File("data/data/" + getPackageName() + "/location.db");
        if (db.exists()){
            return;
        }else {
            AssetManager assets = getAssets();
            try {
                InputStream open = assets.open("naddress.db");
                FileOutputStream fos = new FileOutputStream(db);
                byte[] bytes = new byte[1024];
                int len=-1;
                while ((len=open.read(bytes,0,1024))!=-1){
                    fos.write(bytes,0,len);
                }
                fos.close();
                open.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    
        
## 8.//得到系统的应用的信息

    PackageManager packageManager = ctx.getPackageManager();            //得到系统的应用管理器（包管理器）
            //用这个包管理器就可以得到所有安装应用的信息（应用名称，图片，以及安装在内存卡还是sd卡上等信息）
    List<ApplicationInfo> installedApplications = packageManager.getInstalledApplications(0);
    for (ApplicationInfo appinfo: installedApplications) {              //用foreach即可取出
    CharSequence lable = appinfo.loadLabel(packageManager);             //应用名
    Drawable icon = appinfo.loadIcon(packageManager);                   //应用图片 
## 9.//AsyncTask 轻量级的异步类，用于在类的主线程中实现异步操作（即起一个异步子线程）

    AsyncTask定义了三种泛型类型 Params，Progress和Result。
    •Params         启动任务执行的输入参数，比如HTTP请求的URL。
    •Progress       后台任务执行的百分比。
    •Result         后台执行任务最终返回的结果，比如String。


    使用过AsyncTask 的同学都知道一个异步加载数据最少要重写以下这两个方法：
    •doInBackground(Params…) 后台执行，比较耗时的操作都可以放在这里。注意这里不能直接操作UI。此方法在后台线程执行，完成任务的主要工作，通常需要较长的时间。在执行过程中可以调用publicProgress(Progress…)来更新任务的进度。
    •onPostExecute(Result)  相当于Handler 处理UI的方式，在这里面可以使用在doInBackground 得到的结果处理操作UI。 此方法在主线程执行，任务执行的结果作为此方法的参数返回
    

    有必要的话你还得重写以下这三个方法，但不是必须的：
    •onProgressUpdate(Progress…)    可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。
    •onPreExecute()                 这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。
    •onCancelled()                  用户调用取消时，要做的操作
    

     new AsyncTask<Void, Integer, Float>() {
            List<AppInfo> allAppInfo;
            int count=0;
            //做初始化的操作
            @Override
            protected void onPreExecute() {
                super.onPreExecute();
            }
            //在子线程中做耗时操作
            @Override
            protected Float doInBackground(Void... params) {
                while (count<allAppInfo.size()){
                    publishProgress(++count);
                }
                return null;
            }
            //相当于Handler 处理UI的方式，在这里面可以使用在doInBackground 得到的结果处理操作UI。
            @Override
            protected void onPostExecute(Float aFloat) {
                super.onPostExecute(aFloat);
            }
            //可以使用进度条增加用户体验度。 此方法在主线程执行 ，用于显示任务执行的进度。
            @Override
            protected void onProgressUpdate(Integer... values) {
                pb_clearcache_scan.setProgress(values[0]);
                super.onProgressUpdate(values);
            }
            //用户调用取消时，要做的操作
               @Override
            protected void onCancelled() {
                super.onCancelled();
            }
        }.execute();

## 10.//获取sdkcard的可用空间//获取手机内存的剩余空间

     public static long getAvailableSDcardSize() {
        File SDcard = Environment.getExternalStorageDirectory();    //File SDcard = Environment.getDataDirectory();
        StatFs statFs = new StatFs(SDcard.getAbsolutePath());
        long availableBlocks;
        long blockSize;
        if (Build.VERSION.SDK_INT >= 18) {//如果sdk版本在18以上则用下面的 因为之下的没有这函数
            availableBlocks = statFs.getAvailableBlocksLong();
            blockSize = statFs.getBlockSizeLong();
        } else {
            availableBlocks = statFs.getAvailableBlocks();
            blockSize = statFs.getBlockSize();
        }
        return availableBlocks * blockSize;
    }
    小米4手机的安装目录
     
    就是sd卡，/sdcard或/storage/emulated/legacy/或
    /storage/emulated/0/（我的）或/storage/sdcard0/
    以上4个位置都是小米4的sd根目录
    
## 11.//检测service是否在运行  传一个service的名字 它将返回这个service是否运行

        public class RunningServiceUtils  {
        public static boolean isrunning(Context ctx,String servicename){
            ActivityManager ams = (ActivityManager) ctx.getSystemService(ctx.ACTIVITY_SERVICE);//得到一个管理activity service等的manager
            List<ActivityManager.RunningServiceInfo> runningServices = ams.getRunningServices(100);//传返回service一个最大值
            for (ActivityManager.RunningServiceInfo service:runningServices) {      //对所有运行的service进行遍历如果有这个服务则表示这个服务正在运行
                if (servicename.equals(service.service.getClassName())){            //如果正在运行 则返回true
                    return true;
                }
            }
            return false;
        }
    }
## 12.//开发时，我们时常要获取手机屏幕的高宽数据。

	通常我们会写个获取方法如getScreen();然后在Oncreate()中调用getScreen()方法。我们可能获取到的结果是宽高为0。这是为什么呢？原因在于：在Activity生命周期中，onCreate,onStart,onResume都不是真正屏幕可见（VISIBLE）时间点，真正的VISIBLE时间点是在当onWindowFocusChanged()函数被执行时，此时用户才真正地可以与应用进行交互，而这函数被调用之前，用户的操作都有一点限制。所以我们要正确获取到手机屏幕的宽高，是要在onWindowFocusChanged()方法中来执行。

    @Override
    public void onWindowFocusChanged(boolean hasFocus) {
    int width=getResources().getDisplayMetrics().widthPixels;//获取屏幕宽度
    int hight=getResources().getDisplayMeIntentFilter filter = new IntentFilter();//过滤器
        filter.addAction("com.cskaoyan.mobilemanager.tempunlock");//接受广播动作为com.cskaoyan.mobilemanager.tempunlock的广播
        registerReceiver(receiver,filter);                      //注册广播接受者
        
        //当发出这个的时候内容观察者就会被调用
        getContext().getContentResolver().notifyChange(Uri.parse("content://com.example.administrator"),null);
        //这里注册一个内容观察者 用于当数据库发生变化的时候调用
        getContentResolver().registerContentObserver(Uri.parse("content://com.example.administrator"),false,new MyObserver(new Handler()));
            new Thread(){
                @Override
                public void run() {
                    super.run();
            }.start();
            
        //建一个内容观察者
         class MyObserver extends ContentObserver {
            public MyObserver(Handler handler) {
                super(handler);
            }
            @Override//当内容改变的时候
            public void onChange(boolean selfChange) {
                lockedapplist = dao.getAllLockApp();
                super.onChange(selfChange);
            }
        }
    

    //广播接收者
    class MyReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            tempunlockapp = intent.getStringExtra("package");//得到intent中名字为package的内容
            String action = intent.getAction();
        }
    }
    //两种注册方式都是通过接受到广播后在onreceive中接收广播的
    //静态注册广播接收者
        public class first extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            String resultData = getResultData();
            setResultData("17951"+resultData);
        }
    }
         <receiver android:name=".first">
            <!--监听打电话的广播-->
            <intent-filter>
                <action android:name="android.intent.action.NEW_OUTGOING_CALL"/>
            </intent-filter>
        </receiver>
        
    //发送广播
    public void go33(View v){
        Intent intent = new Intent();
        intent.setAction("zhainaiuhi");
        intent.putExtra("package",10000);
        //无序粘性广播
        sendStickyBroadcast(intent);
        //有序粘性广播
        sendStickyOrderedBroadcast(intent, null, null,0,null,null);
    }
 
## 14.//重写系统的返回方法 由原来的回到上一个页面变为回到桌面  

     @Override
        public void onBackPressed() {
            Intent intent = new Intent();
            intent.setAction(Intent.ACTION_MAIN);
            intent.addCategory(Intent.CATEGORY_HOME);
            startActivity(intent);
        }
## 15. //启动旋转动画


    private void startscan() {
        animation= new RotateAnimation(0,360, Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
        animation.setDuration(2000);//设置旋转一周的毫秒数
        animation.setRepeatCount(-1);//设置一直旋转
        iv_scanvirus_scan.setAnimation(animation);//设置图片的旋转类型
        animation.start();
    }
    //组合动画
        AnimationSet as = new AnimationSet(true);//组合动画的时候需要
        
        RotateAnimation rotateAnimation = new RotateAnimation(0, 360, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
        rotateAnimation.setDuration(3000);
        ScaleAnimation scaleAnimation = new ScaleAnimation(0, 1, 0, 1, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
        scaleAnimation.setDuration(3000);
        AlphaAnimation alphaAnimation = new AlphaAnimation(0,1);//透明度由全透0到实体1
        alphaAnimation.setDuration(3000);
        
        as.addAnimation(rotateAnimation);
        as.addAnimation(scaleAnimation);
        as.addAnimation(alphaAnimation);
        
        rl_splash_bg.setAnimation(as);
        as.start();
        
        //如何修改 Activity 进入和退出动画
        1.在在 styles.xml 中编辑代码
        2.overridePendingTransition(R.anim.fade, R.anim.hold);

## 16.//实现点击时的图片转换效果 在drawable中新建deletenumber_bg.xml文件

    //按下去时的效果图必须放在前面 而且要写state_pressed="true"
    <selector xmlns:android="http://schemas.android.com/apk/res/android">
        <item android:state_pressed="true">
            <bitmap android:src="@drawable/main_clean_icon_pressed"/>
        </item>
        <item  >
            <bitmap android:src="@drawable/main_clean_icon"/>
        </item>
    </selector>
    //引用的时候只要在布局文件中 写上这个就行
    android:background="@drawable/deletenumber_bg"
## 17.//弹出对话框的设计

     import android.support.v7.app.AlertDialog;//导入v7包 不然会显示白底 白字 没有字
     new AlertDialog.Builder(上下文)  (MainActivity.this)
                        .setTitle("确认要删除吗?")
                        .setMessage("当前号码" + listitem.blacknum)
                        .setPositiveButton("确认", new DialogInterface.OnClickListener() {
                            @Override
                            public void onClick(DialogInterface dialog, int which) {
                                        //在这里面做确认的操作
                                }
                            }
                        })
                        .setNegativeButton("取消", null)
                        .show();
## 18. //清除缓存的方法
    //向系统要一个很大的空间 由于当前空间必然不够所以系统会自己去释放已知的缓存 然后清理完成之后 系统会调用回调函数通知我们


     public void clearcache(View v){
            Class<?> pmClass = null;
            pmClass=ClearCatchActivity.class.getClassLoader().loadClass("android.content.pm.PackageManager");//从系统得到系统的包管理器
            Method declaredMethod = pmClass.getDeclaredMethod("freeStorageAndNotify", Long.TYPE, IPackageDataObserver.class);
            declaredMethod.invoke(mPm, Long.MAX_VALUE, new MyIPackageDataObserver());
    }
    //当系统清理完内存后 会调用这个函数
    private class MyIPackageDataObserver extends IPackageDataObserver.Stub {
        @Override
        public void onRemoveCompleted(String packageName, boolean succeeded) throws RemoteException {
        //这里起了一个向主线程发送消息的runOnUiThread函数当然 当然它不是这个函数必须的
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    clearAdapter.notifyDataSetChanged();
                }
            });
        }
    }
## 19.//用于显示用户第一次进入手机防盗时的弹出的对话框界面 而且这里是自定义的dialog样式  把一个view用在了这里

    private void showSetpwdDialog() {
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        View v = View.inflate(this, R.layout.setpwd_dialog, null);
        final TextView et_dialog_pwd = (TextView) v.findViewById(R.id.et_dialog_pwd);
        final TextView et_dialog_pwdcon = (TextView) v.findViewById(R.id.et_dialog_pwdcon);
        Button bt_setpwddialog_confirm = (Button) v.findViewById(R.id.bt_setpwddialog_confirm);
        Button bt_setpwddialog_cancle = (Button) v.findViewById(R.id.bt_setpwddialog_cancle);
        builder.setView(v);//设置dialog的样式为一个view
        final AlertDialog dialog = builder.create();
        dialog.show();
        
        //设置弹出窗口的大小
        WindowManager.LayoutParams  lp= dialog.getWindow().getAttributes();
        lp.width=800;//定义宽度
        lp.height=1000;//定义高度
        dialog.getWindow().setAttributes(lp);
        
        
        //点击确定的话
        bt_setpwddialog_confirm.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String pwd = et_dialog_pwd.getText().toString();
                String pwdcon = et_dialog_pwdcon.getText().toString();
                if (!pwd.isEmpty()&&!pwdcon.isEmpty()){
                    //进入判断
                    if (pwd.equals(pwdcon)){
                        MyApplication.setConfigValue("phonesafe_pwd", Md5Utils.getMd5Digest(pwd));
                        dialog.dismiss();
                    }else {
                        Toast.makeText(HomeActivity.this, "用户名或者密码不一致，请重新输入!", Toast.LENGTH_SHORT).show();
                    }
                }else {
                    Toast.makeText(HomeActivity.this, "用户名或者密码不能为空!", Toast.LENGTH_SHORT).show();
                }
            }
        });
        bt_setpwddialog_cancle.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                dialog.dismiss();
            }
        });
    }
## 20.//关于应用的三个操作在listview中

    //开启应用 
    private void start() {
        //根据当前点击的app的包名，去获取该app的启动intent。
        Intent intent = getPackageManager().getLaunchIntentForPackage(current_click_appInfo.getPackagename());
        startActivity(intent);
    }
    //分享应用
    private void share() {
        Intent intent = new Intent();
        intent.setAction(Intent.ACTION_SEND);
        intent.setType("text/plain");
        intent.putExtra(Intent.EXTRA_TEXT, "推荐一个好玩的app给你" + current_click_appInfo.getAppname() + "下载地址 http://www.baidu.com/xx.apk");
        startActivity(intent);
    }
    //卸载应用
    private void uninstall() {
        //这里做判断 如果应用为自己或者系统的应用就给出不能卸载的提示
        if (getPackageName().equals(current_click_appInfo.getPackagename())){
            Toast.makeText(PackageManagerActivity.this, "无法卸载自己！", Toast.LENGTH_SHORT).show();
            return;
        }else if (current_click_appInfo.isSystem()){
            Toast.makeText(PackageManagerActivity.this, "无法卸载系统应用！", Toast.LENGTH_SHORT).show();
            return;
        }
        Intent intent = new Intent();
        intent.setAction(Intent.ACTION_DELETE);
        intent.setData(Uri.parse("package:" + current_click_appInfo.getPackagename()));
        startActivityForResult(intent, 100);
    }

## 21.//将当前的页面从任务栈结束掉 这样返回键就不会回到这里了

    private void enterHome() {
        startActivity(new Intent(SplashActivity.this, HomeActivity.class));
        finish();//将当前的页面从任务栈结束掉 这样返回键就不会回到这里了
    }

    

## 22.//TextView的静态自定义自己的类型 当然也可以定制别的  在src/values中

    <resources>
    <style name="myPageTile">
        <item name="android:layout_width">match_parent</item>
        <item name="android:layout_height">60dp</item>
        <item name="android:gravity">center</item>
        <item name="android:textSize">40sp</item>
        <item name="android:background">@drawable/bamboo</item>
    </style>       
    </resources>
    //用的时候
     <TextView
        style="@style/myPageTile"
        android:text="高级工具"/>
    //自定义的view（加上了逻辑的）加
    xmlns:settingitem="http://schemas.android.com/apk/res-auto"
   
    
       
## 23.//拿到每个应用的缓存信息 由于不能直接拿 所以用反射的方法来拿 getPackageSizeInfo   

    //得到类（ClearCatchActivity为当前的activity）
    Class<?> pmClass = ClearCatchActivity.this.getClassLoader().loadClass("android.content.pm.PackageManager");
    //得到类中的方法
    Method getPackageSizeInfo = pmClass.getMethod("getPackageSizeInfo", String.class, IPackageStatsObserver.class);
    //拿到缓存的信息
    getPackageSizeInfo.invoke(mPm,allAppInfo.get(count).getPackagename(),mStatsObserver); 

## 24.//第三方控件的引入

    xmlns:settingitem="http://schemas.android.com/apk/res-auto"
## 25.//listview的小操作

    //设置项目分割线样式与宽度
    android:divider="@android:color/darker_gray"
    android:dividerHeight="10dp"
    //去掉滚动条
    android:scrollbars="none"
    //去掉点击效果
    android:listSelector="#00000000"
    android:listSelector="@android:color/transparent"//或者设成透明的
    //得到第i个view
    View view = listview.getChildAt(i);
    //给空的listview设置一个图片
    listview.setEmptyView(findViewById(R.id.image));
     //获得当前的最后一个item在listview中的位置数
    int i = view.getLastVisiblePosition();
    //得到keshi



## 26.//系统提供的将字节数转换为Mb的函数

     String s=Formatter.formatFileSize(this, bytes);//bytes要传的字节数  s为返回的自动变化的文件大小

## 27.//此函数为激活管理员权限  因为正常的激活管理员权限很麻烦 所以在此设置了跳转页面 从而方便客户进行设置

        public void active(View v){
            Intent intent = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN);
            ComponentName mDeviceAdminSample = new ComponentName(this,MyDericeAdminReceiver.class);
            intent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN,mDeviceAdminSample  );
            intent.putExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION,"hello,kitty");
            startActivityForResult(intent, 100);
        }
   

## 28.//调用系统的安装函数进行安装更新的apk这是刚更新的

    private void install(File f) {
        Intent intent = new Intent();
        intent.setAction("android.intent.action.VIEW");
        intent.addCategory("android.intent.category.DEFAULT");
        intent.setDataAndType(Uri.fromFile(f), "application/vnd.android.package-archive");
        startActivity(intent);
    }        
## 29.//得到当前的版本号

    PackageManager manager = getPackageManager();
    PackageInfo packageInfo = manager.getPackageInfo(getPackageName(), 0);
    int versionCode = packageInfo.versionCode;//当前的版本号 用的是int型的
    String versionName = packageInfo.versionName;//当前的版本号 用的是name
## 30.//ViewPager的适配器 可以左右滑动的控件

    class MyPagerAdapter extends PagerAdapter{
     private List<Fragment> pageInfoList;
        //返回显示页面的个数
        @Override
        public int getCount() {
            return pageInfoList.size();
        }
        //实例化item  返回值为一个存储这个页面数据的对象 即isViewFromObject中传入的object。
        @Override
        public Object instantiateItem(ViewGroup container, int position) {
            MyPageInfo myPageInfo = pageInfoList.get(position);//新建一个当前位置的myPageInfo（页面信息）
            container.addView(myPageInfo.iv);   //  将页面信息中的图片传入
            return myPageInfo;
        }
        
        //判断当前页面对应的view是否是在当前页面对应的对象（object）中。
        @Override
        public boolean isViewFromObject(View view, Object object) {
            MyPageInfo pageInfo= (MyPageInfo) object;
            return view==pageInfo.iv;
        }
        
        //销毁滑出屏幕的view
        @Override
        public void destroyItem(ViewGroup container, int position, Object object) {
            MyPageInfo PageInfo= (MyPageInfo) object;
            container.removeView(PageInfo.iv);
        }
         @Override
        public Fragment getItem(int position) {
            return fragmentList.get(position);
        }
    }
     
    优化：当页面比较卡的时候 加上这句 就会自动多存储3个页面 从而不会将fragment销毁新建 不会卡
    contentPager.setOffscreenPageLimit(3);



## 31.//自己画一个圆  greypoint.xml

    <shape xmlns:android="http://schemas.android.com/apk/res/android"
        android:shape="oval">//oval表示圆
        <solid android:color="@android:color/darker_gray"/>
    </shape>
     
    LinearLayout ll_guide_indicator;
    View view = new View(this);
    view.setBackgroundResource(R.drawable.greypoint);//将布局设入
    LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(20, 20);
    view.setLayoutParams(params);//将布局设到view中
    ll_guide_indicator.addView(view);
## 32.//绘图-自己画一个圆 用Java语言画

    ImageView image = (ImageView) findViewById(R.id.image);
    int width=getResources().getDisplayMetrics().widthPixels;//屏幕宽度
    int hight=getResources().getDisplayMetrics().heightPixels;//屏幕高度
     
    Bitmap bitmap = Bitmap.createBitmap(width, hight, Bitmap.Config.ARGB_8888);//创建画纸
    Canvas canvas = new Canvas(bitmap);//创建画板
    Paint paint = new Paint();//创建画笔
    paint.setStyle(Paint.Style.STROKE);//STROKE设置样式为空心的 FILL设置样式为实心的
    paint.setAntiAlias(true);//设置抗锯齿
    paint.setStrokeWidth(5);//设置边的宽度为5像素
    canvas.drawCircle(width/2,hight/2,width/2-3,paint);//设置 圆的中心的宽和高  半径这里减掉了3 是为了全部显示  
    image.setImageBitmap(bitmap);//必须将画布放到一个imageview中才能显示
## 33.//图片-图片处理

    ImageView image2 = (ImageView) findViewById(R.id.ic_picture1);
    Bitmap map2 = Bitmap.createBitmap(200, 400, Bitmap.Config.ARGB_4444);
    Canvas canvas = new Canvas(map2);
    Matrix matrix = new Matrix();
    float[] m2={1,0,0,0,1,0,0,0,1};//原矩阵
    //方法1：矩阵变换
    float[] m2={2,0,0,0,2,0,0,0,1};//缩放，
    float[] m2={-1,0,map.getWidth(),0,1,0,0,0,1};//镜面
    float[] m2={1,0,0,0,-1,map.getHeight(),0,0,1};   //倒影
    matrix.setValues(m2);
     
    //方法2：通过调用系统函数
     matrix.setValues(m2);
     matrix.setRotate(45);//旋转45
     matrix.setRotate(degrees, px, py);//这个方法是以哪个点为中心进行旋转多少度  
     matrix.setTranslate(100,100);//位移
     matrix.setScale(1f,2f);//第一个参数为宽度不变  第二个参数为高度变为原来的1/2
     matrix.setScale(1, -1);  //倒影
     
     canvas.drawBitmap(map, matrix, new Paint());
     image2.setImageBitmap(map2);
## 34.//为了解决刚拷贝的图片不能立刻显示的问题 发送广播，重新挂载SD卡 

    private void sendBroadCaseRemountSDcard() {  
        Intent intent = new Intent();  
        // 重新挂载的动作  
        intent.setAction(Intent.ACTION_MEDIA_MOUNTED);  
        // 要重新挂载的路径  
        intent.setData(Uri.fromFile(Environment.getExternalStorageDirectory()));  
        sendBroadcast(intent);  
    }  
## 35.//侧滑菜单的实现

    SlidingMenu slidingMenu= getSlidingMenu(); //得到一个侧滑的菜单
    slidingMenu.setMode(SlidingMenu.LEFT);//设置划出来的方向
    slidingMenu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);
    slidingMenu.setBehindOffset(400);//设置漏出来的页面的长度（像素）
     
    slidingMenu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);//让侧滑菜单显示
    slidingMenu.setTouchModeAbove(SlidingMenu.TOUCHMODE_NONE);//让侧滑菜单不显示
    slidingMenu.toggle();//每次调用时 如果为开就关上  如果为关就打开 

## 36.//字符流复制 解决乱码问题

    InputStreamReader fis=new InputStreamReader(new FileInputStream("categories.json"));
    OutputStreamWriter fos=new OutputStreamWriter(new FileOutputStream("2categories.json"),"utf-8");//用来指定用什么来编码
    int len;
    while ((len=fis.read())!=-1) 
    {
        fos.write(len);
    }
    fos.flush();
    fos.close();
## 37.// 碎片的用法   碎片的用法就是精简版的activity

    FragmentManager fragmentManager = getFragmentManager();
    FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
    ContentFragment contentFragment = new ContentFragment();//这是new出来的碎片
    //将R.id.fl_main_content代表的布局用contentFragment碎片替换  第三个参数可以不写（写的原因是 如果有多个碎片可以更好的区分）
    fragmentTransaction.replace(R.id.fl_main_content, contentFragment,"contentfragment");
    fragmentTransaction.commit();//碎片想事务一样需要提交
     
    public class ContentFragment extends Fragment {
        //在这里面做这个碎片的逻辑 
    }
## 38.// 事件的拦截机制

    dispatchTouchEvent          分发事件    true 时系统会把事件继续传递进来 false 时不穿进来
    onInterceptTouchEvent       拦截事件    true 时会拦截这个事件
    onTouchEvent                处理事件
    framelayout--linearlayout--textview
    当重写这3个方法而且均不做修改时  在

## 39.// webview的使用

    final WebView wv_shownews_content = (WebView) findViewById(R.id.wv_shownews_content);
    wv_shownews_content.loadUrl(url);//将一个完整的URL传进去
     
    <WebView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:id="@+id/wv_shownews_content"></WebView>

## 40.java中的设计模式

    设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因 
     
    设计模式；
    一个程序员对设计模式的理解:
    “不懂”为什么要把很简单的东西搞得那么复杂。后来随着软件开发经验的增加才开始明白我所看到的“复杂”恰恰就是设计模式的精髓所在，我所理解的“简单”就是一把钥匙开一把锁的模式，目的仅仅是着眼于解决现在的问题，而设计模式的“复杂”就在于它是要构造一个“万能钥匙”，目的是提出一种对所有锁的开锁方案。在真正理解设计模式之前我一直在编写“简单”的代码.

[CSDN上的详解][1]
[博客园精髓讲解][2]

## 41.GridLayout  
Android4.0之后推出的新的布局类型 -高级版的TableLayout主要用于网格布局
[CSDN上的详细介绍][3]

## 42.Padding 和 Margin 有什么区别

    android:padding 和 android:layout_margin 的区别，其实概念很简单，padding 是站在父 view 的角度描述问
    题，它规定它里面的内容必须与这个父 view边界的距离。
    margin则是站在自己的角度描述问题，规定自己和其他（上下左右）的 view 之间的距离，如果同一级只有一个 view，那么它的效果基本上就和 padding 一样了。

## 43.Andorid中解析xml的4中方法

    ①dom
    ②sax
    ③JDOM  github上开源控件 利用dom和sax混合解析的
    ④Dom4j
[CSDN上介绍][4]
    
## 44.Andorid解析json的三种方式 

    ①传统的JSON解析
    ②GSON
    ③FastJSON
    
[FastJSON的介绍][5]
## 45.为啥要将dp转换成px

    因为在代码中只能写px没有dp，而且因为从dp转化成的px无论是在mdpi,ndpi,xdpi,xxdpi中都是和你在任何屏幕密度下的布局文件中写的那样的比例来展示的。
## 46.checkbox 的选中状态判断

    checkBox.isChecked(); true表示选中,false表示未选中。
    CheckBox的状态设置方式:
    在xml中 android:check="true" 表示选中
    在xml中 android:check="false" 表示不选中
    在java代码中 check.setChecked(true); 表示选中
    在java代码中 check.setChecked(false); 表示不选中

## 47.常用的正则表达式

     public static String lable_checkIDcard 
     = "^(\\d{15}$|^\\d{18}$|^\\d{17}(\\d|X|x))$";//身份证号
    public static String lable_checkPassword
    ="^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{3,16}$";//密码
    public static String lable_checkPassword = "[0-9A-Za-z]{3,16}";//密码
    public static String lable_checkPhonenumber = "\\d{11}";//手机号
    public static String lable_checkpost = "\\d{6}";//邮政编码
        
     final String idcard = loginEt.getText().toString();
        if (idcard.matches(BaseApplication.lable_checkIDcard)) {}；

	  if (!etZqmj2.getText().toString().trim().matches("^[\u4e00-\u9fa5]{0,}$")) {
	        	UtilsDialogs.showWarningMessage(this, "错误", "执勤民警2必须为中文", null);
	        	return false;
	        };
[介绍][6]
## 48.Handler的用法

    private Handler handler;
            //设置上拉刷新
            @Override
            public void DownToRefresh() {
                handler = new Handler(){
                   @Override
                   public void handleMessage(Message msg) {
                       super.handleMessage(msg);
                       switch (msg.what){
                           case 100:
                               initData();
                               PullToRefreshGroup.onRefreshComplete();
                               break;
                       }
                   }
               };
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        // TODO: 在这里做请求数据的请求操作
                        Message message = new Message();
                        message.what=100;
                        handler.sendMessage(message);
                    }
                }).start();

            }

     
    //定时功能
    curDate = new Date(System.currentTimeMillis());
            handler = new Handler() {
                private String str;
                @Override
                public void handleMessage(Message msg) {
                    super.handleMessage(msg);
                    switch (msg.what) {
                        case 100:
                            curDate = new Date(System.currentTimeMillis());
                            str = formatter.format(curDate);
                            dakaTimeBig.setText(str);
                            break;
                    }
                }
            };
            new Thread(new Runnable() {
                @Override
                public void run() {
                    // TODO: 在这里做请求数据的请求操作
                    while (true) {
                        try {
                            Thread.sleep(1000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        Log.d("HomeActivity", "啊啊啊");
                        Message message = new Message();
                        message.what = 100;
                        handler.sendMessage(message);
                    }
                }
            }).start();
            
            
            
## 49.toast的封装
-避免多次点击出现许多的toast

    public class Util {
    private static Toast toast;
    public static void showToast(Context context, 
        String content) {
        if (toast == null) {
            toast = Toast.makeText(context,
                         content, 
                         Toast.LENGTH_SHORT);
        } else {
            toast.setText(content);
        }
        toast.show();
    }
    }
    调用：Util.showToast(context, "things happened");
## 49.Snackbar

    在使用Snackbar之前，首先需要在app/build.gradle中添加相应的依赖：
    dependencies { compile 'com.android.support:design:23.4.0' }
        
    Snackbar.make(view, "data deleted",Snackbar.LENGTH_LONG)
        .setAction("Undo", new View.OnClickListener(){
                @Override
                public void onClick(View v) {
                }
            })
        .show();
    这里调用Snackbar的make()方法来创建一个Snackbar对象，make()方法的第一个参数需要传入一个view，只要是当前界面布局的任意一个view都可以，Snackbar会使用这个view来自动查找最外层的布局，用于展示Snackbar。第二个参数就是Snackbar中显示的内容，第三个参数是Snackbar显示的时长。这些和Toast都是类似的。
## 50.SerializedName的作用
-为了解决解析的json数据和定义的变量的名称不相符的情况

    @SerializedName("Jqbh")
    private String jqbh = "";//警情编号
[介绍][7]

## 51.== null 的区别 .equals("")

    //判断一个常量是否为空
    TextUtils.isEmpty(values);
## 52.Android异常处理——try、catch、finally、throw、throws
[介绍][8]

## 53.startActivityForResult()、onActivityResult()和setResult()使用
[介绍][9]

    startActivityForResult与onActivityResult
    androidActivity之间的跳转不只是有startActivity(Intent i)的,startActivityForResult(Intent intent, int requestCode)也是常用的方法。
    其作用是可以用onActivityResult(int requestCode, int resultCode, Intent data)方法获得请求Activity结束之后的操作。
    需要注意三个方法：startActivityForResult(Intent intent, int requestCode)，onActivityResult(int requestCode, int resultCode, Intent data)，setResult(int resultCode, Intent data)
    例如如下代码：从From跳转至ToB和ToC
    From：
     
    if(条件){
    Intent intent = new Intent(this, ToB.class);
    startActivityForResult(serverIntent, REQUEST_CODE_01);//跳转至ToB
    }else{
    Intent intent = new Intent(this, ToC.class);
    intent.putExtra("two", "zheshishui");
    startActivityForResult(serverIntent, REQUEST_CODE_02);//跳转至ToC
    }
    public void onActivityResult(int requestCode, int resultCode, Intent data){
              switch (requestCode) {
                     case REQUEST_CODE_01:
                            if(resultCode==Activity.RESULT_OK)
                            //do something
                            String two = data.getStringExtra("two");
                            break;
                     case REQUEST_CODE_02:
                            //do something
                            break;
             }
    }
    这里说说startActivityForResult(Intent intent, int requestCode)的参数，第一个Intent不用说了，需要注意的是第二个，我们用的是REQUEST_CODE_01和REQUEST_CODE_02，其实这个是我们自己定义的一个int型常量，用于标记的，具体作用可在onActivityResult方法里看到，用于判断是从哪个Activity返回的。
     
    ToB：
    //从From中获取intent中的string字符串
    Intent intent = this.getIntent();        //获取已有的intent对象   
	Bundle bundle = intent.getExtras();    //获取intent里面的bundle对象   
	string = bundle.getString("two");    //获取Bundle里面的字符串 
    
    Intent intent = new Intent();
    intent.putExtra(key, value);
    setResult(Activity.RESULT_OK, intent);
    finish();//结束之后会将结果传回From
     
    ToC：
    Intent intent = new Intent();
    intent.putExtra(key, value);
    setResult(Activity.RESULT_OK, intent);
    finish();//结束之后会将结果传回From
     
    setResult的第一个参数对应上面onActivityResult的第二个参数，注意别把onActivityResult的第一个参数与第二个参数搞混淆了，一个是请求标记，一个是返回标记。
## 54.Intent和IntentFilter详解
[链接][10]
## 55.进程和线程
[链接][11]
## 56.Bundle类
[链接][12]
-Bundle类是一个key-value对

        新建一个bundle类
    Bundle mBundle = new Bundle();   
    mBundle.putString("Data", "data from TestBundle")
        bundle类中加入数据（key -value的形式）
    Intent intent = new Intent();    
    intent.setClass(TestBundle.this, Target.class);    
    intent.putExtras(mBundle);  
     
    Bundle bundle = getIntent().getExtras();   //得到传过来的bundle  
    String data = bundle.getString("Data");//读出数据    
    
## 57.newInstance
-实例化对象
[链接][13]

    newInstance: 弱类型。低效率。只能调用无参构造。
    new: 强类型。相对高效。能调用任何public构造
    
## 58.回复Android studio 的默认设置
[链接][14]
## 59.List中toArray()的使用方法
-将一个链表中的数据放到数组的时候使用
[链接][15]
## 60.Java 异常Exception e中e的getMessage()和toString()

    由此可以看出，e.toString()获取的信息包括异常类型和异常详细消息，
    java.lang.NullPointerException
    而e.getMessage()只是获取了异常的详细消息字符串。
    null
## 61.view的setTag() 和 getTag()应用
[链接][16]

    View中的setTag(Onbect)表示给View添加一个格外的数据，以后可以用getTag()将这个数据取出来。 
    Button button1 = (Button) findViewById(R.id.Button01);   
    Button button2 = (Button) findViewById(R.id.Button02); 
     
    MyListener listener = new MyListener();   
    button1.setTag(1);   
    button1.setOnClickListener(listener);   
    button2.setTag(2);   
    button2.setOnClickListener(listener);  
     
    public class MyListener implements View.OnClickListener {  
    @Override  
    public void onClick(View v) {  
        int tag = (Integer) v.getTag();  
        switch (tag){   
        case 1:   
           System.out.println("button1 click");   
        break;   
        case 2:   
           System.out.println("button2 click");   
        break;   
   }
    
## 62.OnKeyListener键盘事件
[链接][17]

    private EditText etSfzhm;
    etSfzhm.setOnKeyListener(new View.OnKeyListener() {
            @Override
            public boolean onKey(View v, int keyCode, KeyEvent event) {
                if (KeyEvent.KEYCODE_ENTER == keyCode) {
                //当键盘收起来的时候
                    if (event.getAction() == KeyEvent.ACTION_UP) {
                        queryCzrk(true);//做查询的操作
                        return true;
                    }
                }
                return false;
            }
        });
## 63.Spinner 控件
[介绍][19]

    // 初始化控件
    Spinner spinner = (Spinner) findViewById(R.id.spinner1);
    // 建立数据源
    String[] mItems = {"C", "Java", "php", "C++", "汇编语言"};
    // 建立Adapter并且绑定数据源
    ArrayAdapter<String> adapter = new ArrayAdapter<String>(this, android.R.layout.simple_spinner_item, mItems);
    adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
    //绑定 Adapter到控件
    spinner.setAdapter(adapter);
    spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
        @Override
        public void onItemSelected(AdapterView<?> parent, View view,
                                   int pos, long id) {
            String[] languages = {"C", "Java", "php", "C++", "汇编语言"};
            Toast.makeText(SpinnerActivity.this, "你点击的是:" + languages[pos], Toast.LENGTH_SHORT).show();
        }
        @Override
        public void onNothingSelected(AdapterView<?> parent) {
            // Another interface callback
        }
    });
     
    <Spinner
            android:id="@+id/spinner1"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
          />
	spinner.setSelection(1,true);// 设置默认选中项
## 64.Android 中的主题
[android 中系统样式自带样式的详解][20]

## 65.Android 中图片的缩略图的显示
[demo实例one][21]
[demo实例two][22]

     //传入要设置的 imageview 和要缩小的倍数 从而缩小图片
    private void showsmalltwophtot(ImageView iv,int i){
        Bitmap bitmap = BitmapFactory.decodeResource(getResources(),imagesource);
        int width = bitmap.getWidth();
        int height = bitmap.getHeight();
        Bitmap bitmap2 = ThumbnailUtils.extractThumbnail(bitmap,width/i,height/i);
        iv.setImageBitmap(bitmap2);
    }
     
    //传入照片的宽高 从而设置图片
    private void showsmalltwophtot(ImageView iv,int width,int height){
        Bitmap bitmap = BitmapFactory.decodeResource(getResources(),imagesource);
        Bitmap bitmap2 = ThumbnailUtils.extractThumbnail(bitmap,width,height);
        iv.setImageBitmap(bitmap2);
    }
## 66.将信息输出到文件中

	 File file = new File(Environment.getExternalStorageDirectory(),"zhai.txt"); 
     Log.i("输出的位置",Environment.getExternalStorageDirectory().toString());
     FileOutputStream outStream = null;
     try {
         outStream = new FileOutputStream(file); 
         outStream.write(userdata.toString().getBytes());
     } catch (IOException e) {
   			  e.printStackTrace();
     } finally{
         try {
                   outStream.close();
         } catch (IOException e) {
                    e.printStackTrace();
         } 
	}
## 67.Android子线程中更新UI的3种方法
[网址][23]

	方法一：用Handler 
    1、主线程中定义Handler： 
    Java代码  收藏代码
    Handler mHandler = new Handler() {  
        @Override  
        public void handleMessage(Message msg) {  
            super.handleMessage(msg);  
            switch (msg.what) {  
            case 0:  
                //完成主界面更新,拿到数据  
                String data = (String)msg.obj;  
                updateWeather();  
                textView.setText(data);  
                break;  
            default:  
                break;  
            }  
        }  
    };  

    2、子线程发消息，通知Handler完成UI更新： 
    Java代码  收藏代码
    private void updateWeather() {  
        new Thread(new Runnable(){  
            @Override  
            public void run() {  
                //耗时操作，完成之后发送消息给Handler，完成UI更新；  
                mHandler.sendEmptyMessage(0);  
                //需要数据传递，用下面方法；  
                Message msg =new Message();  
                msg.obj = "数据";//可以是基本类型，可以是对象，可以是List、map等；  
                mHandler.sendMessage(msg);  
            }  
        }).start();  
    }  

	方法一的Handler对象必须定义在主线程中，如果是多个类直接互相调用，就不是很方便，需要传递content对象或通过接口调用； 

	方法二：用Activity对象的runOnUiThread方法更新 
    在子线程中通过runOnUiThread()方法更新UI： 
    Java代码  收藏代码
    new Thread() {  
            public void run() {  
                //这儿是耗时操作，完成之后更新UI；  
                runOnUiThread(new Runnable(){  
                    @Override  
                    public void run() {  
                        //更新UI  
                        imageView.setImageBitmap(bitmap);  
                    }  
                });  
            }  
        }.start();  

    如果在非上下文类中（Activity），可以通过传递上下文实现调用； 
    Java代码  收藏代码
    Activity activity = (Activity) imageView.getContext();  
                activity.runOnUiThread(new Runnable() {  
                    @Override  
                    public void run() {  
                        imageView.setImageBitmap(bitmap);  
                    }  
                });  
    这种方法使用比较灵活，但如果Thread定义在其他地方，需要传递Activity对象； 
    方法三：View.post(Runnable r) 
    Java代码  收藏代码
    imageView.post(new Runnable(){  
                    @Override  
                    public void run() {  
                        imageView.setImageBitmap(bitmap);  
                    }  
                });  
    这种方法更简单，但需要传递要更新的View过去； 
    总结：UI的更新必须在主线程中完成，所以不管上述那种方法，都是将更新UI的消息发送到了主线程的消息对象，让主线程做处理；




## 68.Intent传递数据

	一、传递List
      1.传递List<String>的方法
      ArrayList<String> info = new ArrayList<String>();  
      info.add(weibo);  
      Intent intent = new Intent(MainActivity.this, ResultActivity.class);  
      intent.putStringArrayListExtra("infoList", info);  
      startActivity(intent);  

      接收
      ArrayList<String> infoList = new ArrayList<String>();  
      infoList = getIntent().getStringArrayListExtra("infoList");  

      2.  传递List<Integer>的方法
      intent.putIntegerArrayListExtra(key, list);      
      list =(ArrayList<Integer>) getIntent().getIntegerArrayListExtra(key);  
    
    二.、传递Object
    
      1.使用Serializable方式
      前提：Object需要实现Serializable接口
      用Serializable方式传递Object的语法：bundle.putSerializable(key,object);
      用Serializable方式接收Object的语法：object=(Object) getIntent().getSerializableExtra(key);
      实现Serializable接口就是把对象序列化，然后再传输，和Java的常用编程没什么明显区别，而且Object不需要明显改变,推荐用这种方式。

      SerInfo serInfo = new SerInfo(name, website, weibo);  
                  Intent intent = new Intent();  
                  Bundle bundle = new Bundle();  
                  bundle.putSerializable("serinfo", serInfo);  
                  intent.setClass(MainActivity.this, ResultActivity.class);  
                  intent.putExtras(bundle);  
                  startActivity(intent);  
          //获得Serializable方式传过来的值  
      SerInfo serInfo = (SerInfo) getIntent().getSerializableExtra("serinfo");  

      2.使用Parcelable方式
      前提：Object需要实现Parcelable接口
      用Parcelable方式传递Object的语法：bundle.putParcelable(key,object);
      用Parcelable方式接收Object的语法：object=(Object) getIntent().getParcelableExtra(key);
      实现Parcelable接口的类比较复杂，Parcelable是个什么东西呢？
    
    三、传递List<Object>
    
    	ArrayList<SerInfo> listObj = new ArrayList<SerInfo>();  
        SerInfo serInfo1 = new SerInfo(name, website, weibo);  
        SerInfo serInfo2 = new SerInfo(name, website, weibo);  
        listObj.add(serInfo1);  
        listObj.add(serInfo2);  
        Intent intent = new Intent();  
        intent.setClass(MainActivity.this, ResultActivity.class);  
        intent.putExtra("listobj", (Serializable) listObj);  
        startActivity(intent);  
    
    	//获得传过来的List<Object>  
        ArrayList<SerInfo> listObj =  (ArrayList<SerInfo>) getIntent().getSerializableExtra("listobj");  
## 69.ANR

	一般主线程超过5秒么有处理就会ANR，需要复杂计算的地方用子线程来实现。
## 70.Listview中adapter的使用

	
	public class Adapter extends BaseAdapter {
		private Context context;
		class ViewHolder {
			private TextView tv1;
			private TextView tv2;
		}
		public Adapter(Context context) {
			this.context = context;
		}
		@Override
		public int getCount() {
			return rwxxList.size();
		}
		@Override
		public Object getItem(int arg0) {
			return rwxxList.get(arg0);
		}
		@Override
		public long getItemId(int arg0) {
			return 0;
		}
		@Override
		public View getView(int arg0, View arg1, ViewGroup arg2) {
			ViewHolder holder = null;
			if (arg1 == null) {
				holder = new ViewHolder();
				arg1 = LayoutInflater.from(RwxxListActivity.this).inflate(R.layout.rwxxlistitem, null);
				holder.tv1 = (TextView) arg1.findViewById(R.id.text1);
				holder.tv2 = (TextView) arg1.findViewById(R.id.text2);
				arg1.setTag(holder);//利用setTagde 方法可以避免listview错位或者多次加载的问题。
			} else {
				holder = (ViewHolder) arg1.getTag();
			}
			Rwxx info = rwxxList.get(arg0);
			holder.tv1.setText("收文日期：" + info.getSwrq());
			holder.tv2.setText("来文机关：" + info.getLwjgStr());
			return arg1;
		}
	};
    
## 71.Handler中Message的使用

	之前是一直使用New Message();的方法。而现在开始用
    Message message = Message.obtain();
    返回一个Message对象,如果在不为空的情况下,Message的对象都是从Message对象池里面拿的实例从而重复使用的,这也为了Android中的Message对象能够更好的回收。
    尤其是在多线程张多次获取对象进行赋值的时候使用，更能节省内存。
## 72.Activity中Finish（）的方法
[介绍][24]
	
    当调用Activity.finish()的时候，系统只是将最上面的Activity移出了栈，并没有及时的调用onDestory（）方法，其占用的资源也没有被及时释放。因为移出了栈，所以当你点击手机上面的“back”按键的时候，也不会找到这个Activity。
    Activity.onDestory()，系统销毁了这个Activity的实例在内存中占据的空间。
	如果想要彻底销毁，


## 73.button监听方式的3中实现方式

	1.匿名内部类实现       当几个监听事件毫无关系  比较少的时候使用
	2.在本类中实现接口实现         当很多监听事件的时候使用
	3.建立一个Listener类来实现       便于很多监听事件共同执行一部分动作的时候使用
## 74. Android定时器Timer.schedule

	TimerTask  checkUploadTask = new TimerTask() {
			public void run() {
				handler.sendEmptyMessage(Global.MESSAGE_CHECKUPLOAD_TIMEOUT);//和sendMessage（Message msg）是一样的，只是在message中调用了message中栈里面的节省资源
			}
		};
	new Timer().schedule(checkUploadTask, 0, 60*60*1000);
	第一个参数"checkUploadTask":   是 TimerTask 类，在包：import Java.util.TimerTask .使用者要继承该类，并实现 public void run() 方法，因为 TimerTask 类实现了 Runnable 接口。
    第二个参数"0"的意思是:(0就表示无延迟)。当你调用该方法后，该方法必然会调用 TimerTask 类 TimerTask 类 中的 run() 方法，这个参数就是这两者之间的差值，转换成汉语的意思就是说，用户调用 schedule() 方法后，要等待这么长的时间才可以第一次执行 run() 方法。
    第三个参数"60*60*1000"的意思就是:  (单位是毫秒60*60*1000为一小时)，  (单位是毫秒3*60*1000为三分钟)  ，第一次调用之后，从第二次开始每隔多长的时间调用一次 run() 方法

## 75. handler中的. post和sendMessage

	1.post方法
	    private Handler handler_post = new Handler();
		handler_post.post(new Runnable() {
                    @Override
                    public void run() {
                        tv_up.setText(new_str);
                    }
                });
       2.sendMessage方法
		Handler handler_senM = new Handler() {
        public void handleMessage(Message msg) {
            if (msg.what == 1) {
                /*sendMessage方法更新UI的操作必须在handler的handleMessage回调中完成*/
                tv_up.setText(new_str);
            }
        };
		new Thread(new Runnable() {
            @Override
            public void run() {
                new_str = "更新UI";
                handler_senM.sendEmptyMessage(1);
            }
        }).start();
	总结： post也没有独特的作用，post本质上还是用sendMessage实现的，post只是一中更方便的用法而已。当然如果是用多个线程，并且区分里面做不同的事的话就用sendmessage吧。

## 76.用adb查看activity的任务栈

	adb shell dumpsys activity

## 77.Activity,Window,WindowManage

	Activity负责界面的生命周期
    Window负责添加和删除界面的window
    WindowManage负责整个window的管理

## 78.CVS的使用

[CVS上介绍][25]
[CVS中文使用手册][26]
# 79.hashmap和LinkedHashMap

	hashmap是无序的
    LinkedHashMap有序的   用额外的链表保证插入顺序

  [1]: http://blog.csdn.net/doymm2008/article/details/13288067
  [2]: http://www.cnblogs.com/hnrainll/archive/2011/12/29/2305582.html
  [3]: http://blog.csdn.net/pku_android/article/details/7343258
  [4]: http://blog.csdn.net/yan8024/article/details/45747971
  [5]: http://blog.csdn.net/zeuskingzb/article/details/17468079
  [6]: http://www.cnblogs.com/gxbk629/p/3591073.html
  [7]: http://www.loongwind.com/archives/125.html
  [8]: http://blog.csdn.net/yangzhaomuma/article/details/49985783
  [9]: http://blog.sina.com.cn/s/blog_6ee3e8b30101ahw5.html
  [10]: http://neast.cn/forum.php?mod=viewthread&tid=34630
  [11]: http://blog.csdn.net/qq_22063697/article/details/52157859?ref=myread
  [12]: http://blog.csdn.net/randyjiawenjie/article/details/6651437
  [13]: http://blog.csdn.net/mengleigaocong/article/details/6907804
  [14]: http://blog.csdn.net/qq_20785431/article/details/50539861
  [15]: http://www.cnblogs.com/yueliming/archive/2013/06/24/3152487.html
  [16]: http://wen66.iteye.com/blog/1224202
  [17]: http://blog.csdn.net/jianghuiquan/article/details/8348731
  [19]: http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0105/2264.html
  [20]: http://blog.csdn.net/y304443320/article/details/41674183
  [21]: http://www.cnblogs.com/kobe8/p/3877125.html
  [22]: http://blog.csdn.net/sjf0115/article/details/7277286
  [23]: http://gqdy365.iteye.com/blog/2112471
  [24]: http://blog.csdn.net/yelangjueqi/article/details/9466347
  [25]: http://wenku.baidu.com/link?url=XdqbWMQ653P4ZJeeFvHrJhI1O-hASc49pC5mSNug51k7tabBtofP7RfZmmHA3gNvz-p-j--D1B879umgGw3lQ1igw7fBtJotrcjyJN2-z3m
  [26]: http://ssg.ustcsz.edu.cn/~zz/doc/cvs/index.html